// This file was automatically generated by:
//  /tools/Slicer3/Slicer3-3.4.1-2009-10-09-linux-x86_64/bin/GenerateCLP --InputXML /home/hamelc/Neurolib/NeuroLib/Applications/StatNonParamTestPDM/shapeAnalysisMANCOVA.xml --OutputCxx /home/hamelc/Neurolib/NeuroLib_linux64/Applications/StatNonParamTestPDM/shapeAnalysisMANCOVACLP.h
//
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <string.h>
#include <vector>
#include <map>

#include <itksys/ios/sstream>

#include "tclap/CmdLine.h"
#include "ModuleProcessInformation.h"

#ifdef WIN32
#define Module_EXPORT __declspec(dllexport)
#else
#define Module_EXPORT 
#endif

#if defined(main) && !defined(REGISTER_TEST)
// If main defined as a preprocessor symbol, redefine it to the expected entry point.
#undef main
#define main ModuleEntryPoint

extern "C" {
  Module_EXPORT char *GetXMLModuleDescription();
  Module_EXPORT int ModuleEntryPoint(int, char*[]);
}
#endif

extern "C" {
Module_EXPORT char XMLModuleDescription[] = 
"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
"<executable>\n"
"  <category>Statistics</category>\n"
"  <title>MANCOVA Shape Analysis Tool</title>\n"
"  <description>shapeAnalysisMANCOVA offers statistical shape analysis based on a parametric boundary description (SPHARM) as the point-based model computing method. The point-based models will be analyzed with the methods here proposed using multivariate analysis of covariance (MANCOVA). Here, the number of variates being tested is the dimensionality of our observations. Each point of these observations is a three dimensional displacement vector from the mean. The number of contrasts is the number of equations involved in the null-hypothesis. In order to encompass varying numbers of variates and contrasts, and to account for independent variables, a matrix computation is performed. This matrix represents the multidimensional aspects of the correlation significance and it can be transformed into a scalar measure by manipulation of its eigenvalues.\n"
" </description>\n"
"  <version>0.0.1.$Revision: 1.2 $(alpha)</version>\n"
"  <documentation-url>http://hdl.handle.net/10380/3124</documentation-url>\n"
"  <license></license>\n"
"  <contributor>Beatriz Paniagua, Marc Niethammer, Marc Macenko, Corentin Hamel</contributor>\n"
"\n"
"  <parameters>\n"
"    <label>I/O Files</label>\n"
"    <file>\n"
"    <name>infile</name>\n"
"    <label>Input File</label>\n"
"    <channel>input</channel>\n"
"    <index>1</index>\n"
"    <description>File which contains all of the data to be analyzed. File is a list pointing to other data sources.</description>\n"
"    </file>\n"
"    \n"
"    <integer>\n"
"    <name>infileColumn</name>\n"
"    <label>Input File Column</label>\n"
"    <longflag>--infileColumn</longflag>\n"
"    <default>0</default>\n"
"    <description>Choose the column of the input file containing the testing surface. Index starting at 0.</description>\n"
"    </integer>\n"
"	\n"
"    <string>\n"
"    <name>outbase</name>\n"
"    <label>Name base for output files</label>\n"
"    <longflag>--out</longflag>\n"
"    <flag>o</flag>\n"
"    <default>statResult</default>\n"
"    <description>All output files will have this as their base.</description>\n"
"    </string>\n"
"  </parameters>\n"
"  \n"
"  <parameters>\n"
"    <label>Input Reading Parameters</label>\n"
"    <description>Input paramters in order to read the input file</description>\n"
"    \n"
"    <integer>\n"
"    <name>numPerms</name>\n"
"    <label>Number of permutations to perform.</label>\n"
"    <longflag>--numPerms</longflag>\n"
"    <flag>n</flag>\n"
"    <description>Number of permutations to perform.</description>\n"
"    <default>10000</default>\n"
"    <constraints>\n"
"    <minimum>1</minimum>\n"
"    <step>1</step>\n"
"    </constraints>\n"
"    </integer>\n"
"	\n"
"    <integer>\n"
"    <name>numGroupTypes</name>\n"
"    <label>Number of different classification types.</label>\n"
"    <longflag>--numGroupTypes</longflag>\n"
"    <flag>g</flag>\n"
"    <description>Number of different classification types.</description>\n"
"    <default>1</default>\n"
"    <constraints>\n"
"    <minimum>1</minimum>\n"
"    <step>1</step>\n"
"    </constraints>\n"
"    </integer>\n"
"    \n"
"    <integer-vector>\n"
"    <name>groupTypeColumns</name>\n"
"    <label>Columns containing a Group Type</label>\n"
"    <longflag>--columnGroupTypes</longflag>\n"
"    <description>Columns containing a Group Type. Index is starting at 0.</description>\n"
"    <default>0</default>\n"
"    </integer-vector>\n"
"    \n"
"    <integer>\n"
"    <name>numIndependent</name>\n"
"    <label>Number of different independent variables.</label>\n"
"    <longflag>--numIndependent</longflag>\n"
"    <flag>i</flag>\n"
"    <description>Number of different independent variables associated with each subject.</description>\n"
"    <default>0</default>\n"
"    <constraints>\n"
"    <minimum>0</minimum>\n"
"    <step>1</step>\n"
"    </constraints>\n"
"    </integer>\n"
"    \n"
"    <integer-vector>\n"
"    <name>independentColumns</name>\n"
"    <label>Columns containing independent variables</label>\n"
"    <longflag>--columnIndependent</longflag>\n"
"    <description>Columns containing independent variables. Index is starting at 0.</description>\n"
"    <default>0</default>\n"
"    </integer-vector>\n"
"    \n"
"    <boolean>\n"
"	<name>surfListScale</name>\n"
"	<label>Scale all point data by the cube-root of the scale factor.</label>\n"
"	<default>false</default>\n"
"	<longflag>--scale</longflag>\n"
"	<flag>s</flag>\n"
"	<description>Scale all point data by the cube-root of the scale factor found in the input file. This is typically used for correcting differences such as varying intercranial volumes (ICV).</description>\n"
"    </boolean>\n"
"    \n"
"    <integer>\n"
"	<name>scaleColumn</name>\n"
"	<label>Column containing the scale factor</label>\n"
"	<longflag>--scaleColumn</longflag>\n"
"	<default>0</default>\n"
"	<description>Column containing the scale factor. Index is starting a 0.</description>\n"
"    </integer>\n"
"	\n"
"    <integer>\n"
"    <name>testColumn</name>\n"
"    <label>Column tested</label>\n"
"    <longflag>--testColumn</longflag>\n"
"    <flag>t</flag>\n"
"    <description>Which column of the data is being tested (0 based). If this is a standard \"Group Test\", it will be one of the group columns. If it is an \"Interaction Test\", it will be one of the independent variable columns.</description>\n"
"    <default>0</default>\n"
"    <constraints>\n"
"    <minimum>0</minimum>\n"
"    <step>1</step>\n"
"    </constraints>\n"
"    </integer>\n"
"    \n"
"    \n"
"    <boolean>\n"
"	<name>KWMreadableInputFile</name>\n"
"	<label> Input KWMeshVisu readable feature (vector) file.</label>\n"
"	<default>false</default>\n"
"	<longflag>--KWMinput</longflag>\n"
"	<description> Input data will be obtained from a KWMeshVisu readable feature (vector) file instead of the 3-d coordinates in a MeshFile.</description>\n"
"    </boolean>\n"
"</parameters>\n"
"\n"
"  <parameters>\n"
"    <label>Analysis Parameters</label>\n"
"    <description>Parameters for the shape analysis</description>\n"
"    \n"
"    <double>\n"
"    <name>significanceLevel</name>\n"
"    <label>Cutoff of p-values considering significant.</label>\n"
"    <longflag>--significanceLevel</longflag>\n"
"    <flag>p</flag>\n"
"    <description>What cutoff of p-values is considered significant. Only affects the FDR corrected results.</description>\n"
"    <default>0.05</default>\n"
"    <constraints>\n"
"    <minimum>0</minimum>\n"
"    <maximum>1</maximum>\n"
"    <step>.001</step>\n"
"    </constraints>\n"
"    </double>\n"
"\n"
"    <boolean>\n"
"    <name>writeZScores</name>\n"
"    <label> out the z-scores.</label>\n"
"    <longflag>--writeZScores</longflag>\n"
"    <description>Writes out the z-scores. Only uses group assignments from the first group column currently. z-score of group A is computed with mean and standard deviation from group B and vice versa. z-scores are output based on the projections on the mean surface normal as well as the corresponding Mahalanobis distances (where no projection is performed).</description>\n"
"    <default>false</default>\n"
"    </boolean>\n"
"\n"
"    <boolean>\n"
"    <name>computeScaleFactorFromVolumes</name>\n"
"    <label>Compute scale factor from volumes.</label>\n"
"    <default>false</default>\n"
"    <longflag>--computeScaleFactorFromVolumes</longflag>\n"
"    <description>Reinterprets the scaling column values as volumes and compute the scaling factor from them. WARNING: This is different from the traditional file format where these scaling were already pre-computed.</description>\n"
"    </boolean>\n"
"	\n"
"    <boolean>\n"
"    <name>interactionTest</name>\n"
"    <label>Test for statistically significant interaction.</label>\n"
"    <default>false</default>\n"
"    <longflag>--interactionTest</longflag>\n"
"    <flag>a</flag>\n"
"    <description>Instead of a group test, simply test for statistically significant interaction of the data with a single independent variable.</description>\n"
"    </boolean>\n"
"\n"
"    <boolean>\n"
"    <name>simpleCorrs</name>\n"
"    <label>Simple correlations (Spearman, Pearson).</label>\n"
"    <default>false</default>\n"
"    <longflag>--simpleCorrs</longflag>\n"
"    <description>Simple Spearman and Pearson correlations are computed, based on the normal to the average shape. This option is only valid in interaction test mode.</description>\n"
"    </boolean>\n"
"\n"
"    <boolean>\n"
"    <name>computeParametricP</name>\n"
"    <label>Simple corr: Parametric p-value.</label>\n"
"    <default>false</default>\n"
"    <longflag>--simpleCorrsParaP</longflag>\n"
"    <description>Computes the p-value parametrically for the simple correlation test.</description>\n"
"    </boolean>\n"
"    \n"
"    <boolean>\n"
"    <name>debug</name>\n"
"    <label>Outputs additional debugging information.</label>\n"
"    <default>false</default>\n"
"    <longflag>--debug</longflag>\n"
"    <flag>d</flag>\n"
"    <description>Outputs additional debugging information.</description>\n"
"    </boolean>\n"
"\n"
"    <boolean>\n"
"    <name>useRoy</name>\n"
"    <label>Roy statistics.</label>\n"
"    <default>false</default>\n"
"    <longflag>--roy</longflag>\n"
"    <description>Uses Roy statistic for MANCOVA testing.</description>\n"
"    </boolean>\n"
"\n"
"    <boolean>\n"
"    <name>useWilks</name>\n"
"    <label>Wilks statistics.</label>\n"
"    <default>false</default>\n"
"    <longflag>--wilks</longflag>\n"
"    <description>Uses Wilks statistic for MANCOVA testing.</description>\n"
"    </boolean>\n"
"\n"
"    <boolean>\n"
"    <name>useHotelling</name>\n"
"    <label>Hotelling statistics.</label>\n"
"    <default>false</default>\n"
"    <longflag>--hotelling</longflag>\n"
"    <description>Uses Hotelling statistic for MANCOVA testing.</description>\n"
"    </boolean>\n"
"\n"
"    <boolean>\n"
"    <name>usePillai</name>\n"
"    <label>Pillai statistics.</label>\n"
"    <default>false</default>\n"
"    <longflag>--pillai</longflag>\n"
"    <description>Uses Pillai statistic for MANCOVA testing.</description>\n"
"    </boolean>\n"
"\n"
"    <boolean>\n"
"    <name>negativeCorrelation</name>\n"
"    <label>Negative correlation.</label>\n"
"    <default>false</default>\n"
"    <longflag>--negativeCorrelation</longflag>\n"
"    <description>For the simple (non-MANCOVA) correlation, test for negative correlation. (Only works in conjunction with parametric testing!)</description>\n"
"    </boolean>\n"
"\n"
"    <boolean>\n"
"    <name>positiveCorrelation</name>\n"
"    <label>Positive correlation.</label>\n"
"    <default>false</default>\n"
"    <longflag>--positiveCorrelation</longflag>\n"
"    <description>For the simple (non-MANCOVA) correlation, test for positive correlation.(Only works in conjunction with parametric testing!)</description>\n"
"    </boolean>\n"
"\n"
"    <boolean>\n"
"    <name>trendCorrelation</name>\n"
"    <label>Trend correlation.</label>\n"
"    <default>false</default>\n"
"    <longflag>--trendCorrelation</longflag>\n"
"    <description>For the simple (non-MANCOVA) correlation, test for correlation.</description>\n"
"    </boolean>\n"
"    \n"
"</parameters>\n"
"\n"
" </executable>\n"
"\n"
;

}

void
splitString (const std::string &text,
             const std::string &separators,
             std::vector<std::string> &words)
{
  const std::string::size_type n = text.length();
  std::string::size_type start = text.find_first_not_of(separators);
  while (start < n)
    {
    std::string::size_type stop = text.find_first_of(separators, start);
    if (stop > n) stop = n;
    words.push_back(text.substr(start, stop - start));
    start = text.find_first_not_of(separators, stop+1);
    }
}

void
splitFilenames (const std::string &text,
                std::vector<std::string> &words)
{
  const std::string::size_type n = text.length();
  bool quoted;
  std::string comma(",");
  std::string quote("\"");
  std::string::size_type start = text.find_first_not_of(comma);
  while (start < n)
    {
    quoted = false;
    std::string::size_type startq = text.find_first_of(quote, start);
    std::string::size_type stopq = text.find_first_of(quote, startq+1);
    std::string::size_type stop = text.find_first_of(comma, start);
    if (stop > n) stop = n;
    if (startq != std::string::npos && stopq != std::string::npos)
      {
      while (startq < stop && stop < stopq && stop != n)
         {
         quoted = true;
         stop = text.find_first_of(comma, stop+1);
         if (stop > n) stop = n;
         }
      }
    if (!quoted)
      {
      words.push_back(text.substr(start, stop - start));
      }
    else
      {
      words.push_back(text.substr(start+1, stop - start-2));
      }
    start = text.find_first_not_of(comma, stop+1);
    }
}

char *GetXMLModuleDescription()
{
   return XMLModuleDescription;
}

#define GENERATE_LOGO
#define GENERATE_XML \
  if (argc >= 2 && (strcmp(argv[1],"--xml") == 0)) \
    { \
    std::cout << GetXMLModuleDescription(); \
    return EXIT_SUCCESS; \
    }
#define GENERATE_TCLAP \
    std::string infile; \
    int infileColumn = 0; \
    std::string outbase = "statResult"; \
    int numPerms = 10000; \
    int numGroupTypes = 1; \
    std::string groupTypeColumnsTemp = "0"; \
    std::vector<int> groupTypeColumns; \
    int numIndependent = 0; \
    std::string independentColumnsTemp = "0"; \
    std::vector<int> independentColumns; \
    bool surfListScale = false; \
    int scaleColumn = 0; \
    int testColumn = 0; \
    bool KWMreadableInputFile = false; \
    double significanceLevel = 0.05; \
    bool writeZScores = false; \
    bool computeScaleFactorFromVolumes = false; \
    bool interactionTest = false; \
    bool simpleCorrs = false; \
    bool computeParametricP = false; \
    bool debug = false; \
    bool useRoy = false; \
    bool useWilks = false; \
    bool useHotelling = false; \
    bool usePillai = false; \
    bool negativeCorrelation = false; \
    bool positiveCorrelation = false; \
    bool trendCorrelation = false; \
    bool echoSwitch = false; \
    bool xmlSwitch = false; \
    std::string processInformationAddressString = "0"; \
    std::string fullDescription("Description: "); \
    fullDescription += "shapeAnalysisMANCOVA offers statistical shape analysis based on a parametric boundary description (SPHARM) as the point-based model computing method. The point-based models will be analyzed with the methods here proposed using multivariate analysis of covariance (MANCOVA). Here, the number of variates being tested is the dimensionality of our observations. Each point of these observations is a three dimensional displacement vector from the mean. The number of contrasts is the number of equations involved in the null-hypothesis. In order to encompass varying numbers of variates and contrasts, and to account for independent variables, a matrix computation is performed. This matrix represents the multidimensional aspects of the correlation significance and it can be transformed into a scalar measure by manipulation of its eigenvalues."; \
    if (!std::string("Beatriz Paniagua, Marc Niethammer, Marc Macenko, Corentin Hamel").empty()) \
      { \
      fullDescription += "\nAuthor(s): Beatriz Paniagua, Marc Niethammer, Marc Macenko, Corentin Hamel"; \
      } \
    if (!std::string("").empty()) \
      { \
      fullDescription += "\nAcknowledgements: "; \
      } \
    TCLAP::CmdLine commandLine (fullDescription, \
       ' ', \
      "0.0.1.$Revision: 1.2 $(alpha)" ); \
 \
      itksys_ios::ostringstream msg; \
    msg.str("");msg << "File which contains all of the data to be analyzed. File is a list pointing to other data sources.";    TCLAP::UnlabeledValueArg<std::string> infileArg("infile", msg.str(), 1, infile, "std::string", commandLine); \
 \
    msg.str("");msg << "Choose the column of the input file containing the testing surface. Index starting at 0. (default: " << infileColumn << ")"; \
    TCLAP::ValueArg<int > infileColumnArg("", "infileColumn", msg.str(), 0, infileColumn, "int", commandLine); \
 \
    msg.str("");msg << "All output files will have this as their base. (default: " << outbase << ")"; \
    TCLAP::ValueArg<std::string > outbaseArg("o", "out", msg.str(), 0, outbase, "std::string", commandLine); \
 \
    msg.str("");msg << "Number of permutations to perform. (default: " << numPerms << ")"; \
    TCLAP::ValueArg<int > numPermsArg("n", "numPerms", msg.str(), 0, numPerms, "int", commandLine); \
 \
    msg.str("");msg << "Number of different classification types. (default: " << numGroupTypes << ")"; \
    TCLAP::ValueArg<int > numGroupTypesArg("g", "numGroupTypes", msg.str(), 0, numGroupTypes, "int", commandLine); \
 \
    msg.str("");msg << "Columns containing a Group Type. Index is starting at 0. (default: " << groupTypeColumnsTemp << ")"; \
    TCLAP::ValueArg<std::string > groupTypeColumnsArg("", "columnGroupTypes", msg.str(), 0, groupTypeColumnsTemp, "std::vector<int>", commandLine); \
 \
    msg.str("");msg << "Number of different independent variables associated with each subject. (default: " << numIndependent << ")"; \
    TCLAP::ValueArg<int > numIndependentArg("i", "numIndependent", msg.str(), 0, numIndependent, "int", commandLine); \
 \
    msg.str("");msg << "Columns containing independent variables. Index is starting at 0. (default: " << independentColumnsTemp << ")"; \
    TCLAP::ValueArg<std::string > independentColumnsArg("", "columnIndependent", msg.str(), 0, independentColumnsTemp, "std::vector<int>", commandLine); \
 \
    msg.str("");msg << "Scale all point data by the cube-root of the scale factor found in the input file. This is typically used for correcting differences such as varying intercranial volumes (ICV). (default: " << surfListScale << ")"; \
    TCLAP::SwitchArg surfListScaleArg("s", "scale", msg.str(), commandLine, surfListScale); \
 \
    msg.str("");msg << "Column containing the scale factor. Index is starting a 0. (default: " << scaleColumn << ")"; \
    TCLAP::ValueArg<int > scaleColumnArg("", "scaleColumn", msg.str(), 0, scaleColumn, "int", commandLine); \
 \
    msg.str("");msg << "Which column of the data is being tested (0 based). If this is a standard 'Group Test', it will be one of the group columns. If it is an 'Interaction Test', it will be one of the independent variable columns. (default: " << testColumn << ")"; \
    TCLAP::ValueArg<int > testColumnArg("t", "testColumn", msg.str(), 0, testColumn, "int", commandLine); \
 \
    msg.str("");msg << "Input data will be obtained from a KWMeshVisu readable feature (vector) file instead of the 3-d coordinates in a MeshFile. (default: " << KWMreadableInputFile << ")"; \
    TCLAP::SwitchArg KWMreadableInputFileArg("", "KWMinput", msg.str(), commandLine, KWMreadableInputFile); \
 \
    msg.str("");msg << "What cutoff of p-values is considered significant. Only affects the FDR corrected results. (default: " << significanceLevel << ")"; \
    TCLAP::ValueArg<double > significanceLevelArg("p", "significanceLevel", msg.str(), 0, significanceLevel, "double", commandLine); \
 \
    msg.str("");msg << "Writes out the z-scores. Only uses group assignments from the first group column currently. z-score of group A is computed with mean and standard deviation from group B and vice versa. z-scores are output based on the projections on the mean surface normal as well as the corresponding Mahalanobis distances (where no projection is performed). (default: " << writeZScores << ")"; \
    TCLAP::SwitchArg writeZScoresArg("", "writeZScores", msg.str(), commandLine, writeZScores); \
 \
    msg.str("");msg << "Reinterprets the scaling column values as volumes and compute the scaling factor from them. WARNING: This is different from the traditional file format where these scaling were already pre-computed. (default: " << computeScaleFactorFromVolumes << ")"; \
    TCLAP::SwitchArg computeScaleFactorFromVolumesArg("", "computeScaleFactorFromVolumes", msg.str(), commandLine, computeScaleFactorFromVolumes); \
 \
    msg.str("");msg << "Instead of a group test, simply test for statistically significant interaction of the data with a single independent variable. (default: " << interactionTest << ")"; \
    TCLAP::SwitchArg interactionTestArg("a", "interactionTest", msg.str(), commandLine, interactionTest); \
 \
    msg.str("");msg << "Simple Spearman and Pearson correlations are computed, based on the normal to the average shape. This option is only valid in interaction test mode. (default: " << simpleCorrs << ")"; \
    TCLAP::SwitchArg simpleCorrsArg("", "simpleCorrs", msg.str(), commandLine, simpleCorrs); \
 \
    msg.str("");msg << "Computes the p-value parametrically for the simple correlation test. (default: " << computeParametricP << ")"; \
    TCLAP::SwitchArg computeParametricPArg("", "simpleCorrsParaP", msg.str(), commandLine, computeParametricP); \
 \
    msg.str("");msg << "Outputs additional debugging information. (default: " << debug << ")"; \
    TCLAP::SwitchArg debugArg("d", "debug", msg.str(), commandLine, debug); \
 \
    msg.str("");msg << "Uses Roy statistic for MANCOVA testing. (default: " << useRoy << ")"; \
    TCLAP::SwitchArg useRoyArg("", "roy", msg.str(), commandLine, useRoy); \
 \
    msg.str("");msg << "Uses Wilks statistic for MANCOVA testing. (default: " << useWilks << ")"; \
    TCLAP::SwitchArg useWilksArg("", "wilks", msg.str(), commandLine, useWilks); \
 \
    msg.str("");msg << "Uses Hotelling statistic for MANCOVA testing. (default: " << useHotelling << ")"; \
    TCLAP::SwitchArg useHotellingArg("", "hotelling", msg.str(), commandLine, useHotelling); \
 \
    msg.str("");msg << "Uses Pillai statistic for MANCOVA testing. (default: " << usePillai << ")"; \
    TCLAP::SwitchArg usePillaiArg("", "pillai", msg.str(), commandLine, usePillai); \
 \
    msg.str("");msg << "For the simple (non-MANCOVA) correlation, test for negative correlation. (Only works in conjunction with parametric testing!) (default: " << negativeCorrelation << ")"; \
    TCLAP::SwitchArg negativeCorrelationArg("", "negativeCorrelation", msg.str(), commandLine, negativeCorrelation); \
 \
    msg.str("");msg << "For the simple (non-MANCOVA) correlation, test for positive correlation.(Only works in conjunction with parametric testing!) (default: " << positiveCorrelation << ")"; \
    TCLAP::SwitchArg positiveCorrelationArg("", "positiveCorrelation", msg.str(), commandLine, positiveCorrelation); \
 \
    msg.str("");msg << "For the simple (non-MANCOVA) correlation, test for correlation. (default: " << trendCorrelation << ")"; \
    TCLAP::SwitchArg trendCorrelationArg("", "trendCorrelation", msg.str(), commandLine, trendCorrelation); \
 \
    msg.str("");msg << "Echo the command line arguments (default: " << echoSwitch << ")"; \
    TCLAP::SwitchArg echoSwitchArg("", "echo", msg.str(), commandLine, echoSwitch); \
 \
    msg.str("");msg << "Produce xml description of command line arguments (default: " << xmlSwitch << ")"; \
    TCLAP::SwitchArg xmlSwitchArg("", "xml", msg.str(), commandLine, xmlSwitch); \
 \
    msg.str("");msg << "Address of a structure to store process information (progress, abort, etc.). (default: " << processInformationAddressString << ")"; \
    TCLAP::ValueArg<std::string > processInformationAddressStringArg("", "processinformationaddress", msg.str(), 0, processInformationAddressString, "std::string", commandLine); \
 \
try \
  { \
    /* Build a map of flag aliases to the true flag */ \
    std::map<std::string,std::string> flagAliasMap; \
    std::map<std::string,std::string> deprecatedFlagAliasMap; \
    std::map<std::string,std::string> longFlagAliasMap; \
    std::map<std::string,std::string> deprecatedLongFlagAliasMap; \
    /* Remap flag aliases to the true flag */ \
    std::vector<std::string> targs; \
    std::map<std::string,std::string>::iterator ait; \
    std::map<std::string,std::string>::iterator dait; \
    size_t ac; \
    for (ac=0; ac < static_cast<size_t>(argc); ++ac)  \
       {  \
       if (strlen(argv[ac]) == 2 && argv[ac][0]=='-') \
         { \
         /* short flag case */ \
         std::string tflag(argv[ac], 1, strlen(argv[ac])-1); \
         ait = flagAliasMap.find(tflag); \
         dait = deprecatedFlagAliasMap.find(tflag); \
         if (ait != flagAliasMap.end() || dait != deprecatedFlagAliasMap.end()) \
           { \
           if (ait != flagAliasMap.end()) \
             { \
             /* remap the flag */ \
             targs.push_back("-" + (*ait).second); \
             } \
           else if (dait != deprecatedFlagAliasMap.end()) \
             { \
             std::cout << "Flag \"" << argv[ac] << "\" is deprecated. Please use flag \"-" << (*dait).second << "\" instead. " << std::endl; \
             /* remap the flag */ \
             targs.push_back("-" + (*dait).second); \
             } \
           } \
         else \
           { \
           targs.push_back(argv[ac]); \
           } \
         } \
       else if (strlen(argv[ac]) > 2 && argv[ac][0]=='-' && argv[ac][1]=='-') \
         { \
         /* long flag case */ \
         std::string tflag(argv[ac], 2, strlen(argv[ac])-2); \
         ait = longFlagAliasMap.find(tflag); \
         dait = deprecatedLongFlagAliasMap.find(tflag); \
         if (ait != longFlagAliasMap.end() || dait != deprecatedLongFlagAliasMap.end()) \
           { \
           if (ait != longFlagAliasMap.end()) \
             { \
             /* remap the flag */ \
             targs.push_back("--" + (*ait).second); \
             } \
           else if (dait != deprecatedLongFlagAliasMap.end()) \
             { \
             std::cout << "Long flag \"" << argv[ac] << "\" is deprecated. Please use long flag \"--" << (*dait).second << "\" instead. " << std::endl; \
             /* remap the flag */ \
             targs.push_back("--" + (*dait).second); \
             } \
           } \
         else \
           { \
           targs.push_back(argv[ac]); \
           } \
         } \
       else if (strlen(argv[ac]) > 2 && argv[ac][0]=='-' && argv[ac][1]!='-') \
         { \
         /* short flag case where multiple flags are given at once ala */ \
         /* "ls -ltr" */ \
         std::string tflag(argv[ac], 1, strlen(argv[ac])-1); \
         std::string rflag("-"); \
         for (std::string::size_type fi=0; fi < tflag.size(); ++fi) \
           { \
           std::string tf(tflag, fi, 1); \
           ait = flagAliasMap.find(tf); \
           dait = deprecatedFlagAliasMap.find(tf); \
           if (ait != flagAliasMap.end() || dait != deprecatedFlagAliasMap.end()) \
             { \
             if (ait != flagAliasMap.end()) \
               { \
               /* remap the flag */ \
               rflag += (*ait).second; \
               } \
             else if (dait != deprecatedFlagAliasMap.end()) \
               { \
               std::cout << "Flag \"-" << tf << "\" is deprecated. Please use flag \"-" << (*dait).second << "\" instead. " << std::endl; \
               /* remap the flag */ \
               rflag += (*dait).second; \
               } \
             } \
           else \
             { \
             rflag += tf; \
             } \
           } \
         targs.push_back(rflag); \
         } \
       else \
         { \
         /* skip the argument without remapping (this is the case for any */ \
         /* arguments for flags */ \
         targs.push_back(argv[ac]); \
         } \
       } \
 \
   /* Remap args to a structure that CmdLine::parse() can understand*/ \
   std::vector<char*> vargs; \
   for (ac = 0; ac < targs.size(); ++ac) \
     {  \
     vargs.push_back(const_cast<char *>(targs[ac].c_str())); \
     } \
    commandLine.parse ( vargs.size(), (char**) &(vargs[0]) ); \
    infile = infileArg.getValue(); \
    infileColumn = infileColumnArg.getValue(); \
    outbase = outbaseArg.getValue(); \
    numPerms = numPermsArg.getValue(); \
    numGroupTypes = numGroupTypesArg.getValue(); \
    groupTypeColumnsTemp = groupTypeColumnsArg.getValue(); \
    numIndependent = numIndependentArg.getValue(); \
    independentColumnsTemp = independentColumnsArg.getValue(); \
    surfListScale = surfListScaleArg.getValue(); \
    scaleColumn = scaleColumnArg.getValue(); \
    testColumn = testColumnArg.getValue(); \
    KWMreadableInputFile = KWMreadableInputFileArg.getValue(); \
    significanceLevel = significanceLevelArg.getValue(); \
    writeZScores = writeZScoresArg.getValue(); \
    computeScaleFactorFromVolumes = computeScaleFactorFromVolumesArg.getValue(); \
    interactionTest = interactionTestArg.getValue(); \
    simpleCorrs = simpleCorrsArg.getValue(); \
    computeParametricP = computeParametricPArg.getValue(); \
    debug = debugArg.getValue(); \
    useRoy = useRoyArg.getValue(); \
    useWilks = useWilksArg.getValue(); \
    useHotelling = useHotellingArg.getValue(); \
    usePillai = usePillaiArg.getValue(); \
    negativeCorrelation = negativeCorrelationArg.getValue(); \
    positiveCorrelation = positiveCorrelationArg.getValue(); \
    trendCorrelation = trendCorrelationArg.getValue(); \
    echoSwitch = echoSwitchArg.getValue(); \
    xmlSwitch = xmlSwitchArg.getValue(); \
    processInformationAddressString = processInformationAddressStringArg.getValue(); \
      { /* Assignment for groupTypeColumns */ \
      std::vector<std::string> words; \
      std::string sep(","); \
      splitString(groupTypeColumnsTemp, sep, words); \
      for (unsigned int _j = 0; _j < words.size(); _j++) \
        { \
        groupTypeColumns.push_back(atoi(words[_j].c_str())); \
        } \
      } \
      { /* Assignment for independentColumns */ \
      std::vector<std::string> words; \
      std::string sep(","); \
      splitString(independentColumnsTemp, sep, words); \
      for (unsigned int _j = 0; _j < words.size(); _j++) \
        { \
        independentColumns.push_back(atoi(words[_j].c_str())); \
        } \
      } \
  } \
catch ( TCLAP::ArgException e ) \
  { \
  std::cerr << "error: " << e.error() << " for arg " << e.argId() << std::endl; \
  return ( EXIT_FAILURE ); \
  }
#define GENERATE_ECHOARGS \
if (echoSwitch) \
{ \
std::cout << "Command Line Arguments" << std::endl; \
std::cout << "    infile: " << infile << std::endl; \
std::cout << "    infileColumn: " << infileColumn << std::endl; \
std::cout << "    outbase: " << outbase << std::endl; \
std::cout << "    numPerms: " << numPerms << std::endl; \
std::cout << "    numGroupTypes: " << numGroupTypes << std::endl; \
std::cout << "    groupTypeColumns: "; \
for (unsigned int _i =0; _i < groupTypeColumns.size(); _i++) \
{ \
std::cout << groupTypeColumns[_i] << ", "; \
} \
std::cout <<std::endl; \
std::cout << "    numIndependent: " << numIndependent << std::endl; \
std::cout << "    independentColumns: "; \
for (unsigned int _i =0; _i < independentColumns.size(); _i++) \
{ \
std::cout << independentColumns[_i] << ", "; \
} \
std::cout <<std::endl; \
std::cout << "    surfListScale: " << surfListScale << std::endl; \
std::cout << "    scaleColumn: " << scaleColumn << std::endl; \
std::cout << "    testColumn: " << testColumn << std::endl; \
std::cout << "    KWMreadableInputFile: " << KWMreadableInputFile << std::endl; \
std::cout << "    significanceLevel: " << significanceLevel << std::endl; \
std::cout << "    writeZScores: " << writeZScores << std::endl; \
std::cout << "    computeScaleFactorFromVolumes: " << computeScaleFactorFromVolumes << std::endl; \
std::cout << "    interactionTest: " << interactionTest << std::endl; \
std::cout << "    simpleCorrs: " << simpleCorrs << std::endl; \
std::cout << "    computeParametricP: " << computeParametricP << std::endl; \
std::cout << "    debug: " << debug << std::endl; \
std::cout << "    useRoy: " << useRoy << std::endl; \
std::cout << "    useWilks: " << useWilks << std::endl; \
std::cout << "    useHotelling: " << useHotelling << std::endl; \
std::cout << "    usePillai: " << usePillai << std::endl; \
std::cout << "    negativeCorrelation: " << negativeCorrelation << std::endl; \
std::cout << "    positiveCorrelation: " << positiveCorrelation << std::endl; \
std::cout << "    trendCorrelation: " << trendCorrelation << std::endl; \
std::cout << "    echoSwitch: " << echoSwitch << std::endl; \
std::cout << "    xmlSwitch: " << xmlSwitch << std::endl; \
std::cout << "    processInformationAddressString: " << processInformationAddressString << std::endl; \
}
#define GENERATE_ProcessInformationAddressDecoding \
ModuleProcessInformation *CLPProcessInformation = 0; \
if (processInformationAddressString != "") \
{ \
sscanf(processInformationAddressString.c_str(), "%p", &CLPProcessInformation); \
}
#define PARSE_ARGS GENERATE_LOGO;GENERATE_XML;GENERATE_TCLAP;GENERATE_ECHOARGS;GENERATE_ProcessInformationAddressDecoding;
